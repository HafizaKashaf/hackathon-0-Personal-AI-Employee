"""
File System Watcher

Monitors a drop folder for new files and creates action files
in the Needs_Action folder for Claude Code to process.

This is the simplest watcher to set up - just drop files into
the Inbox folder and they'll be processed automatically.
"""

import shutil
import hashlib
from pathlib import Path
from datetime import datetime
from base_watcher import BaseWatcher


class FileSystemWatcher(BaseWatcher):
    """
    Watches the Inbox folder for new files.
    
    When a file is detected, it creates:
    1. A copy in Needs_Action folder
    2. A metadata .md file with action items
    """
    
    def __init__(self, vault_path: str, check_interval: int = 30):
        """
        Initialize the file system watcher.
        
        Args:
            vault_path: Path to the Obsidian vault root
            check_interval: Seconds between checks (default: 30)
        """
        super().__init__(vault_path, check_interval)
        self.processed_files = set()
        
    def check_for_updates(self) -> list:
        """
        Check the Inbox folder for new files.
        
        Returns:
            List of new file paths to process
        """
        new_files = []
        
        # Check all files in inbox (not directories)
        for file_path in self.inbox.iterdir():
            if file_path.is_file():
                # Create a hash to track if we've seen this file
                file_hash = self._file_hash(file_path)
                
                if file_hash not in self.processed_files:
                    new_files.append(file_path)
                    self.processed_files.add(file_hash)
                    self.logger.info(f'New file detected: {file_path.name}')
        
        return new_files
    
    def _file_hash(self, file_path: Path) -> str:
        """
        Calculate MD5 hash of a file for tracking.
        
        Args:
            file_path: Path to the file
            
        Returns:
            MD5 hash string
        """
        hash_md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    
    def create_action_file(self, file_path: Path) -> Path:
        """
        Create an action file for the detected file.
        
        Args:
            file_path: Path to the detected file
            
        Returns:
            Path to the created action file
        """
        # Copy file to Needs_Action
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        dest_name = f"FILE_{timestamp}_{file_path.name}"
        dest_path = self.needs_action / dest_name
        
        # Copy the file
        shutil.copy2(file_path, dest_path)
        
        # Create metadata file
        meta_path = self.needs_action / f"{dest_name}.meta.md"
        
        file_size = file_path.stat().st_size
        content = f"""---
type: file_drop
original_name: {file_path.name}
copied_name: {dest_name}
size: {file_size}
detected: {datetime.now().isoformat()}
priority: medium
status: pending
---

# File Drop for Processing

A new file was dropped into the Inbox folder.

## File Details
- **Original Name**: {file_path.name}
- **Size**: {self._format_size(file_size)}
- **Detected**: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Suggested Actions
- [ ] Review the file content
- [ ] Determine required action
- [ ] Process and move to /Done when complete

## File Location
The file has been copied to: `{dest_name}`

---
*Generated by FileSystemWatcher v0.1*
"""
        
        meta_path.write_text(content)
        self.logger.info(f'Created metadata file: {meta_path.name}')
        
        return meta_path
    
    def _format_size(self, size_bytes: int) -> str:
        """
        Format file size in human-readable format.
        
        Args:
            size_bytes: Size in bytes
            
        Returns:
            Formatted string (e.g., "1.5 KB")
        """
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024
        return f"{size_bytes:.1f} TB"


if __name__ == '__main__':
    import sys

    # Get vault path from command line or use default
    if len(sys.argv) > 1:
        vault_path = sys.argv[1]
    else:
        # Default: parent directory (the vault root)
        vault_path = str(Path(__file__).parent.parent)
        print(f"Using default vault path: {vault_path}")

    watcher = FileSystemWatcher(vault_path, check_interval=30)
    watcher.run()
